{"ast":null,"code":"import { BufferAttribute, BufferGeometry, ClampToEdgeWrapping, FileLoader, Group, NoColorSpace, Loader, Mesh, MeshPhysicalMaterial, MirroredRepeatWrapping, RepeatWrapping, SRGBColorSpace, TextureLoader, Object3D, Vector2 } from 'three';\nimport * as fflate from '../libs/fflate.module.js';\nclass USDAParser {\n  parse(text) {\n    const data = {};\n    const lines = text.split('\\n');\n    let string = null;\n    let target = data;\n    const stack = [data];\n\n    // debugger;\n\n    for (const line of lines) {\n      // console.log( line );\n\n      if (line.includes('=')) {\n        const assignment = line.split('=');\n        const lhs = assignment[0].trim();\n        const rhs = assignment[1].trim();\n        if (rhs.endsWith('{')) {\n          const group = {};\n          stack.push(group);\n          target[lhs] = group;\n          target = group;\n        } else {\n          target[lhs] = rhs;\n        }\n      } else if (line.endsWith('{')) {\n        const group = target[string] || {};\n        stack.push(group);\n        target[string] = group;\n        target = group;\n      } else if (line.endsWith('}')) {\n        stack.pop();\n        if (stack.length === 0) continue;\n        target = stack[stack.length - 1];\n      } else if (line.endsWith('(')) {\n        const meta = {};\n        stack.push(meta);\n        string = line.split('(')[0].trim() || string;\n        target[string] = meta;\n        target = meta;\n      } else if (line.endsWith(')')) {\n        stack.pop();\n        target = stack[stack.length - 1];\n      } else {\n        string = line.trim();\n      }\n    }\n    return data;\n  }\n}\nclass USDZLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(buffer) {\n    const parser = new USDAParser();\n    function parseAssets(zip) {\n      const data = {};\n      const loader = new FileLoader();\n      loader.setResponseType('arraybuffer');\n      for (const filename in zip) {\n        if (filename.endsWith('png')) {\n          const blob = new Blob([zip[filename]], {\n            type: {\n              type: 'image/png'\n            }\n          });\n          data[filename] = URL.createObjectURL(blob);\n        }\n        if (filename.endsWith('usd') || filename.endsWith('usda')) {\n          if (isCrateFile(zip[filename])) {\n            console.warn('THREE.USDZLoader: Crate files (.usdc or binary .usd) are not supported.');\n            continue;\n          }\n          const text = fflate.strFromU8(zip[filename]);\n          data[filename] = parser.parse(text);\n        }\n      }\n      return data;\n    }\n    function isCrateFile(buffer) {\n      // Check if this a crate file. First 7 bytes of a crate file are \"PXR-USDC\".\n      const fileHeader = buffer.slice(0, 7);\n      const crateHeader = new Uint8Array([0x50, 0x58, 0x52, 0x2D, 0x55, 0x53, 0x44, 0x43]);\n\n      // If this is not a crate file, we assume it is a plain USDA file.\n      return fileHeader.every((value, index) => value === crateHeader[index]);\n    }\n    function findUSD(zip) {\n      if (zip.length < 1) return undefined;\n      const firstFileName = Object.keys(zip)[0];\n      let isCrate = false;\n\n      // As per the USD specification, the first entry in the zip archive is used as the main file (\"UsdStage\").\n      // ASCII files can end in either .usda or .usd.\n      // See https://openusd.org/release/spec_usdz.html#layout\n      if (firstFileName.endsWith('usda')) return zip[firstFileName];\n      if (firstFileName.endsWith('usdc')) {\n        isCrate = true;\n      } else if (firstFileName.endsWith('usd')) {\n        // If this is not a crate file, we assume it is a plain USDA file.\n        if (!isCrateFile(zip[firstFileName])) {\n          return zip[firstFileName];\n        } else {\n          isCrate = true;\n        }\n      }\n      if (isCrate) {\n        console.warn('THREE.USDZLoader: Crate files (.usdc or binary .usd) are not supported.');\n      }\n      return undefined;\n    }\n    const zip = fflate.unzipSync(new Uint8Array(buffer));\n\n    // console.log( zip );\n\n    const assets = parseAssets(zip);\n\n    // console.log( assets )\n\n    const file = findUSD(zip);\n    if (file === undefined) {\n      console.warn('THREE.USDZLoader: No usda file found.');\n      return new Group();\n    }\n\n    // Parse file\n\n    const text = fflate.strFromU8(file);\n    const root = parser.parse(text);\n\n    // Build scene\n\n    function findMeshGeometry(data) {\n      if (!data) return undefined;\n      if ('prepend references' in data) {\n        const reference = data['prepend references'];\n        const parts = reference.split('@');\n        const path = parts[1].replace(/^.\\//, '');\n        const id = parts[2].replace(/^<\\//, '').replace(/>$/, '');\n        return findGeometry(assets[path], id);\n      }\n      return findGeometry(data);\n    }\n    function findGeometry(data, id) {\n      if (!data) return undefined;\n      if (id !== undefined) {\n        const def = `def Mesh \"${id}\"`;\n        if (def in data) {\n          return data[def];\n        }\n      }\n      for (const name in data) {\n        const object = data[name];\n        if (name.startsWith('def Mesh')) {\n          // Move points to Mesh\n\n          if ('point3f[] points' in data) {\n            object['point3f[] points'] = data['point3f[] points'];\n          }\n\n          // Move st to Mesh\n\n          if ('texCoord2f[] primvars:st' in data) {\n            object['texCoord2f[] primvars:st'] = data['texCoord2f[] primvars:st'];\n          }\n\n          // Move st indices to Mesh\n\n          if ('int[] primvars:st:indices' in data) {\n            object['int[] primvars:st:indices'] = data['int[] primvars:st:indices'];\n          }\n          return object;\n        }\n        if (typeof object === 'object') {\n          const geometry = findGeometry(object);\n          if (geometry) return geometry;\n        }\n      }\n    }\n    function buildGeometry(data) {\n      if (!data) return undefined;\n      let geometry = new BufferGeometry();\n      if ('int[] faceVertexIndices' in data) {\n        const indices = JSON.parse(data['int[] faceVertexIndices']);\n        geometry.setIndex(indices);\n      }\n      if ('point3f[] points' in data) {\n        const positions = JSON.parse(data['point3f[] points'].replace(/[()]*/g, ''));\n        const attribute = new BufferAttribute(new Float32Array(positions), 3);\n        geometry.setAttribute('position', attribute);\n      }\n      if ('normal3f[] normals' in data) {\n        const normals = JSON.parse(data['normal3f[] normals'].replace(/[()]*/g, ''));\n        const attribute = new BufferAttribute(new Float32Array(normals), 3);\n        geometry.setAttribute('normal', attribute);\n      } else {\n        geometry.computeVertexNormals();\n      }\n      if ('float2[] primvars:st' in data) {\n        data['texCoord2f[] primvars:st'] = data['float2[] primvars:st'];\n      }\n      if ('texCoord2f[] primvars:st' in data) {\n        const uvs = JSON.parse(data['texCoord2f[] primvars:st'].replace(/[()]*/g, ''));\n        const attribute = new BufferAttribute(new Float32Array(uvs), 2);\n        if ('int[] primvars:st:indices' in data) {\n          geometry = geometry.toNonIndexed();\n          const indices = JSON.parse(data['int[] primvars:st:indices']);\n          geometry.setAttribute('uv', toFlatBufferAttribute(attribute, indices));\n        } else {\n          geometry.setAttribute('uv', attribute);\n        }\n      }\n      return geometry;\n    }\n    function toFlatBufferAttribute(attribute, indices) {\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      const array2 = new array.constructor(indices.length * itemSize);\n      let index = 0,\n        index2 = 0;\n      for (let i = 0, l = indices.length; i < l; i++) {\n        index = indices[i] * itemSize;\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n      return new BufferAttribute(array2, itemSize);\n    }\n    function findMeshMaterial(data) {\n      if (!data) return undefined;\n      if ('rel material:binding' in data) {\n        const reference = data['rel material:binding'];\n        const id = reference.replace(/^<\\//, '').replace(/>$/, '');\n        const parts = id.split('/');\n        return findMaterial(root, ` \"${parts[1]}\"`);\n      }\n      return findMaterial(data);\n    }\n    function findMaterial(data, id = '') {\n      for (const name in data) {\n        const object = data[name];\n        if (name.startsWith('def Material' + id)) {\n          return object;\n        }\n        if (typeof object === 'object') {\n          const material = findMaterial(object, id);\n          if (material) return material;\n        }\n      }\n    }\n    function setTextureParams(map, data_value) {\n      // rotation, scale and translation\n\n      if (data_value['float inputs:rotation']) {\n        map.rotation = parseFloat(data_value['float inputs:rotation']);\n      }\n      if (data_value['float2 inputs:scale']) {\n        map.repeat = new Vector2().fromArray(JSON.parse('[' + data_value['float2 inputs:scale'].replace(/[()]*/g, '') + ']'));\n      }\n      if (data_value['float2 inputs:translation']) {\n        map.offset = new Vector2().fromArray(JSON.parse('[' + data_value['float2 inputs:translation'].replace(/[()]*/g, '') + ']'));\n      }\n    }\n    function buildMaterial(data) {\n      const material = new MeshPhysicalMaterial();\n      if (data !== undefined) {\n        if ('def Shader \"PreviewSurface\"' in data) {\n          const surface = data['def Shader \"PreviewSurface\"'];\n          if ('color3f inputs:diffuseColor.connect' in surface) {\n            const path = surface['color3f inputs:diffuseColor.connect'];\n            const sampler = findTexture(root, /(\\w+).output/.exec(path)[1]);\n            material.map = buildTexture(sampler);\n            material.map.colorSpace = SRGBColorSpace;\n            if ('def Shader \"Transform2d_diffuse\"' in data) {\n              setTextureParams(material.map, data['def Shader \"Transform2d_diffuse\"']);\n            }\n          } else if ('color3f inputs:diffuseColor' in surface) {\n            const color = surface['color3f inputs:diffuseColor'].replace(/[()]*/g, '');\n            material.color.fromArray(JSON.parse('[' + color + ']'));\n          }\n          if ('color3f inputs:emissiveColor.connect' in surface) {\n            const path = surface['color3f inputs:emissiveColor.connect'];\n            const sampler = findTexture(root, /(\\w+).output/.exec(path)[1]);\n            material.emissiveMap = buildTexture(sampler);\n            material.emissiveMap.colorSpace = SRGBColorSpace;\n            material.emissive.set(0xffffff);\n            if ('def Shader \"Transform2d_emissive\"' in data) {\n              setTextureParams(material.emissiveMap, data['def Shader \"Transform2d_emissive\"']);\n            }\n          } else if ('color3f inputs:emissiveColor' in surface) {\n            const color = surface['color3f inputs:emissiveColor'].replace(/[()]*/g, '');\n            material.emissive.fromArray(JSON.parse('[' + color + ']'));\n          }\n          if ('normal3f inputs:normal.connect' in surface) {\n            const path = surface['normal3f inputs:normal.connect'];\n            const sampler = findTexture(root, /(\\w+).output/.exec(path)[1]);\n            material.normalMap = buildTexture(sampler);\n            material.normalMap.colorSpace = NoColorSpace;\n            if ('def Shader \"Transform2d_normal\"' in data) {\n              setTextureParams(material.normalMap, data['def Shader \"Transform2d_normal\"']);\n            }\n          }\n          if ('float inputs:roughness.connect' in surface) {\n            const path = surface['float inputs:roughness.connect'];\n            const sampler = findTexture(root, /(\\w+).output/.exec(path)[1]);\n            material.roughness = 1.0;\n            material.roughnessMap = buildTexture(sampler);\n            material.roughnessMap.colorSpace = NoColorSpace;\n            if ('def Shader \"Transform2d_roughness\"' in data) {\n              setTextureParams(material.roughnessMap, data['def Shader \"Transform2d_roughness\"']);\n            }\n          } else if ('float inputs:roughness' in surface) {\n            material.roughness = parseFloat(surface['float inputs:roughness']);\n          }\n          if ('float inputs:metallic.connect' in surface) {\n            const path = surface['float inputs:metallic.connect'];\n            const sampler = findTexture(root, /(\\w+).output/.exec(path)[1]);\n            material.metalness = 1.0;\n            material.metalnessMap = buildTexture(sampler);\n            material.metalnessMap.colorSpace = NoColorSpace;\n            if ('def Shader \"Transform2d_metallic\"' in data) {\n              setTextureParams(material.metalnessMap, data['def Shader \"Transform2d_metallic\"']);\n            }\n          } else if ('float inputs:metallic' in surface) {\n            material.metalness = parseFloat(surface['float inputs:metallic']);\n          }\n          if ('float inputs:clearcoat.connect' in surface) {\n            const path = surface['float inputs:clearcoat.connect'];\n            const sampler = findTexture(root, /(\\w+).output/.exec(path)[1]);\n            material.clearcoat = 1.0;\n            material.clearcoatMap = buildTexture(sampler);\n            material.clearcoatMap.colorSpace = NoColorSpace;\n            if ('def Shader \"Transform2d_clearcoat\"' in data) {\n              setTextureParams(material.clearcoatMap, data['def Shader \"Transform2d_clearcoat\"']);\n            }\n          } else if ('float inputs:clearcoat' in surface) {\n            material.clearcoat = parseFloat(surface['float inputs:clearcoat']);\n          }\n          if ('float inputs:clearcoatRoughness.connect' in surface) {\n            const path = surface['float inputs:clearcoatRoughness.connect'];\n            const sampler = findTexture(root, /(\\w+).output/.exec(path)[1]);\n            material.clearcoatRoughness = 1.0;\n            material.clearcoatRoughnessMap = buildTexture(sampler);\n            material.clearcoatRoughnessMap.colorSpace = NoColorSpace;\n            if ('def Shader \"Transform2d_clearcoatRoughness\"' in data) {\n              setTextureParams(material.clearcoatRoughnessMap, data['def Shader \"Transform2d_clearcoatRoughness\"']);\n            }\n          } else if ('float inputs:clearcoatRoughness' in surface) {\n            material.clearcoatRoughness = parseFloat(surface['float inputs:clearcoatRoughness']);\n          }\n          if ('float inputs:ior' in surface) {\n            material.ior = parseFloat(surface['float inputs:ior']);\n          }\n          if ('float inputs:occlusion.connect' in surface) {\n            const path = surface['float inputs:occlusion.connect'];\n            const sampler = findTexture(root, /(\\w+).output/.exec(path)[1]);\n            material.aoMap = buildTexture(sampler);\n            material.aoMap.colorSpace = NoColorSpace;\n            if ('def Shader \"Transform2d_occlusion\"' in data) {\n              setTextureParams(material.aoMap, data['def Shader \"Transform2d_occlusion\"']);\n            }\n          }\n        }\n        if ('def Shader \"diffuseColor_texture\"' in data) {\n          const sampler = data['def Shader \"diffuseColor_texture\"'];\n          material.map = buildTexture(sampler);\n          material.map.colorSpace = SRGBColorSpace;\n        }\n        if ('def Shader \"normal_texture\"' in data) {\n          const sampler = data['def Shader \"normal_texture\"'];\n          material.normalMap = buildTexture(sampler);\n          material.normalMap.colorSpace = NoColorSpace;\n        }\n      }\n      return material;\n    }\n    function findTexture(data, id) {\n      for (const name in data) {\n        const object = data[name];\n        if (name.startsWith(`def Shader \"${id}\"`)) {\n          return object;\n        }\n        if (typeof object === 'object') {\n          const texture = findTexture(object, id);\n          if (texture) return texture;\n        }\n      }\n    }\n    function buildTexture(data) {\n      if ('asset inputs:file' in data) {\n        const path = data['asset inputs:file'].replace(/@*/g, '');\n        const loader = new TextureLoader();\n        const texture = loader.load(assets[path]);\n        const map = {\n          '\"clamp\"': ClampToEdgeWrapping,\n          '\"mirror\"': MirroredRepeatWrapping,\n          '\"repeat\"': RepeatWrapping\n        };\n        if ('token inputs:wrapS' in data) {\n          texture.wrapS = map[data['token inputs:wrapS']];\n        }\n        if ('token inputs:wrapT' in data) {\n          texture.wrapT = map[data['token inputs:wrapT']];\n        }\n        return texture;\n      }\n      return null;\n    }\n    function buildObject(data) {\n      const geometry = buildGeometry(findMeshGeometry(data));\n      const material = buildMaterial(findMeshMaterial(data));\n      const mesh = geometry ? new Mesh(geometry, material) : new Object3D();\n      if ('matrix4d xformOp:transform' in data) {\n        const array = JSON.parse('[' + data['matrix4d xformOp:transform'].replace(/[()]*/g, '') + ']');\n        mesh.matrix.fromArray(array);\n        mesh.matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);\n      }\n      return mesh;\n    }\n    function buildHierarchy(data, group) {\n      for (const name in data) {\n        if (name.startsWith('def Scope')) {\n          buildHierarchy(data[name], group);\n        } else if (name.startsWith('def Xform')) {\n          const mesh = buildObject(data[name]);\n          if (/def Xform \"(\\w+)\"/.test(name)) {\n            mesh.name = /def Xform \"(\\w+)\"/.exec(name)[1];\n          }\n          group.add(mesh);\n          buildHierarchy(data[name], mesh);\n        }\n      }\n    }\n    const group = new Group();\n    buildHierarchy(root, group);\n    return group;\n  }\n}\nexport { USDZLoader };","map":{"version":3,"names":["BufferAttribute","BufferGeometry","ClampToEdgeWrapping","FileLoader","Group","NoColorSpace","Loader","Mesh","MeshPhysicalMaterial","MirroredRepeatWrapping","RepeatWrapping","SRGBColorSpace","TextureLoader","Object3D","Vector2","fflate","USDAParser","parse","text","data","lines","split","string","target","stack","line","includes","assignment","lhs","trim","rhs","endsWith","group","push","pop","length","meta","USDZLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","e","console","error","itemError","buffer","parser","parseAssets","zip","filename","blob","Blob","type","URL","createObjectURL","isCrateFile","warn","strFromU8","fileHeader","slice","crateHeader","Uint8Array","every","value","index","findUSD","undefined","firstFileName","Object","keys","isCrate","unzipSync","assets","file","root","findMeshGeometry","reference","parts","replace","id","findGeometry","def","name","object","startsWith","geometry","buildGeometry","indices","JSON","setIndex","positions","attribute","Float32Array","setAttribute","normals","computeVertexNormals","uvs","toNonIndexed","toFlatBufferAttribute","array","itemSize","array2","index2","i","l","j","findMeshMaterial","findMaterial","material","setTextureParams","map","data_value","rotation","parseFloat","repeat","fromArray","offset","buildMaterial","surface","sampler","findTexture","exec","buildTexture","colorSpace","color","emissiveMap","emissive","set","normalMap","roughness","roughnessMap","metalness","metalnessMap","clearcoat","clearcoatMap","clearcoatRoughness","clearcoatRoughnessMap","ior","aoMap","texture","wrapS","wrapT","buildObject","mesh","matrix","decompose","position","quaternion","scale","buildHierarchy","test","add"],"sources":["/Users/chenyangdu/Downloads/digital-human-project-updated/digital-human-frontend/src/USDZLoader.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tFileLoader,\n\tGroup,\n\tNoColorSpace,\n\tLoader,\n\tMesh,\n\tMeshPhysicalMaterial,\n\tMirroredRepeatWrapping,\n\tRepeatWrapping,\n\tSRGBColorSpace,\n\tTextureLoader,\n\tObject3D,\n\tVector2\n} from 'three';\n\nimport * as fflate from '../libs/fflate.module.js';\n\nclass USDAParser {\n\n\tparse( text ) {\n\n\t\tconst data = {};\n\n\t\tconst lines = text.split( '\\n' );\n\n\t\tlet string = null;\n\t\tlet target = data;\n\n\t\tconst stack = [ data ];\n\n\t\t// debugger;\n\n\t\tfor ( const line of lines ) {\n\n\t\t\t// console.log( line );\n\n\t\t\tif ( line.includes( '=' ) ) {\n\n\t\t\t\tconst assignment = line.split( '=' );\n\n\t\t\t\tconst lhs = assignment[ 0 ].trim();\n\t\t\t\tconst rhs = assignment[ 1 ].trim();\n\n\t\t\t\tif ( rhs.endsWith( '{' ) ) {\n\n\t\t\t\t\tconst group = {};\n\t\t\t\t\tstack.push( group );\n\n\t\t\t\t\ttarget[ lhs ] = group;\n\t\t\t\t\ttarget = group;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget[ lhs ] = rhs;\n\n\t\t\t\t}\n\n\t\t\t} else if ( line.endsWith( '{' ) ) {\n\n\t\t\t\tconst group = target[ string ] || {};\n\t\t\t\tstack.push( group );\n\n\t\t\t\ttarget[ string ] = group;\n\t\t\t\ttarget = group;\n\n\t\t\t} else if ( line.endsWith( '}' ) ) {\n\n\t\t\t\tstack.pop();\n\n\t\t\t\tif ( stack.length === 0 ) continue;\n\n\t\t\t\ttarget = stack[ stack.length - 1 ];\n\n\t\t\t} else if ( line.endsWith( '(' ) ) {\n\n\t\t\t\tconst meta = {};\n\t\t\t\tstack.push( meta );\n\n\t\t\t\tstring = line.split( '(' )[ 0 ].trim() || string;\n\n\t\t\t\ttarget[ string ] = meta;\n\t\t\t\ttarget = meta;\n\n\t\t\t} else if ( line.endsWith( ')' ) ) {\n\n\t\t\t\tstack.pop();\n\n\t\t\t\ttarget = stack[ stack.length - 1 ];\n\n\t\t\t} else {\n\n\t\t\t\tstring = line.trim();\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass USDZLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( buffer ) {\n\n\t\tconst parser = new USDAParser();\n\n\t\tfunction parseAssets( zip ) {\n\n\t\t\tconst data = {};\n\t\t\tconst loader = new FileLoader();\n\t\t\tloader.setResponseType( 'arraybuffer' );\n\n\t\t\tfor ( const filename in zip ) {\n\n\t\t\t\tif ( filename.endsWith( 'png' ) ) {\n\n\t\t\t\t\tconst blob = new Blob( [ zip[ filename ] ], { type: { type: 'image/png' } } );\n\t\t\t\t\tdata[ filename ] = URL.createObjectURL( blob );\n\n\t\t\t\t}\n\n\t\t\t\tif ( filename.endsWith( 'usd' ) || filename.endsWith( 'usda' ) ) {\n\n\t\t\t\t\tif ( isCrateFile( zip[ filename ] ) ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.USDZLoader: Crate files (.usdc or binary .usd) are not supported.' );\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst text = fflate.strFromU8( zip[ filename ] );\n\t\t\t\t\tdata[ filename ] = parser.parse( text );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction isCrateFile( buffer ) {\n\n\t\t\t// Check if this a crate file. First 7 bytes of a crate file are \"PXR-USDC\".\n\t\t\tconst fileHeader = buffer.slice( 0, 7 );\n\t\t\tconst crateHeader = new Uint8Array( [ 0x50, 0x58, 0x52, 0x2D, 0x55, 0x53, 0x44, 0x43 ] );\n\n\t\t\t// If this is not a crate file, we assume it is a plain USDA file.\n\t\t\treturn fileHeader.every( ( value, index ) => value === crateHeader[ index ] );\n\n\t\t}\n\n\t\tfunction findUSD( zip ) {\n\n\t\t\tif ( zip.length < 1 ) return undefined;\n\n\t\t\tconst firstFileName = Object.keys( zip )[ 0 ];\n\t\t\tlet isCrate = false;\n\n\t\t\t// As per the USD specification, the first entry in the zip archive is used as the main file (\"UsdStage\").\n\t\t\t// ASCII files can end in either .usda or .usd.\n\t\t\t// See https://openusd.org/release/spec_usdz.html#layout\n\t\t\tif ( firstFileName.endsWith( 'usda' ) ) return zip[ firstFileName ];\n\n\t\t\tif ( firstFileName.endsWith( 'usdc' ) ) {\n\n\t\t\t\tisCrate = true;\n\n\t\t\t} else if ( firstFileName.endsWith( 'usd' ) ) {\n\n\t\t\t\t// If this is not a crate file, we assume it is a plain USDA file.\n\t\t\t\tif ( ! isCrateFile( zip[ firstFileName ] ) ) {\n\n\t\t\t\t\treturn zip[ firstFileName ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tisCrate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( isCrate ) {\n\n\t\t\t\tconsole.warn( 'THREE.USDZLoader: Crate files (.usdc or binary .usd) are not supported.' );\n\n\t\t\t}\n\n\t\t\treturn undefined;\n\n\t\t}\n\n\t\tconst zip = fflate.unzipSync( new Uint8Array( buffer ) );\n\n\t\t// console.log( zip );\n\n\t\tconst assets = parseAssets( zip );\n\n\t\t// console.log( assets )\n\n\t\tconst file = findUSD( zip );\n\n\t\tif ( file === undefined ) {\n\n\t\t\tconsole.warn( 'THREE.USDZLoader: No usda file found.' );\n\n\t\t\treturn new Group();\n\n\t\t}\n\n\n\t\t// Parse file\n\n\t\tconst text = fflate.strFromU8( file );\n\t\tconst root = parser.parse( text );\n\n\t\t// Build scene\n\n\t\tfunction findMeshGeometry( data ) {\n\n\t\t\tif ( ! data ) return undefined;\n\n\t\t\tif ( 'prepend references' in data ) {\n\n\t\t\t\tconst reference = data[ 'prepend references' ];\n\t\t\t\tconst parts = reference.split( '@' );\n\t\t\t\tconst path = parts[ 1 ].replace( /^.\\//, '' );\n\t\t\t\tconst id = parts[ 2 ].replace( /^<\\//, '' ).replace( />$/, '' );\n\n\t\t\t\treturn findGeometry( assets[ path ], id );\n\n\t\t\t}\n\n\t\t\treturn findGeometry( data );\n\n\t\t}\n\n\t\tfunction findGeometry( data, id ) {\n\n\t\t\tif ( ! data ) return undefined;\n\n\t\t\tif ( id !== undefined ) {\n\n\t\t\t\tconst def = `def Mesh \"${id}\"`;\n\n\t\t\t\tif ( def in data ) {\n\n\t\t\t\t\treturn data[ def ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( const name in data ) {\n\n\t\t\t\tconst object = data[ name ];\n\n\t\t\t\tif ( name.startsWith( 'def Mesh' ) ) {\n\n\t\t\t\t\t// Move points to Mesh\n\n\t\t\t\t\tif ( 'point3f[] points' in data ) {\n\n\t\t\t\t\t\tobject[ 'point3f[] points' ] = data[ 'point3f[] points' ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Move st to Mesh\n\n\t\t\t\t\tif ( 'texCoord2f[] primvars:st' in data ) {\n\n\t\t\t\t\t\tobject[ 'texCoord2f[] primvars:st' ] = data[ 'texCoord2f[] primvars:st' ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Move st indices to Mesh\n\n\t\t\t\t\tif ( 'int[] primvars:st:indices' in data ) {\n\n\t\t\t\t\t\tobject[ 'int[] primvars:st:indices' ] = data[ 'int[] primvars:st:indices' ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn object;\n\n\t\t\t\t}\n\n\n\t\t\t\tif ( typeof object === 'object' ) {\n\n\t\t\t\t\tconst geometry = findGeometry( object );\n\n\t\t\t\t\tif ( geometry ) return geometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildGeometry( data ) {\n\n\t\t\tif ( ! data ) return undefined;\n\n\t\t\tlet geometry = new BufferGeometry();\n\n\t\t\tif ( 'int[] faceVertexIndices' in data ) {\n\n\t\t\t\tconst indices = JSON.parse( data[ 'int[] faceVertexIndices' ] );\n\t\t\t\tgeometry.setIndex( indices );\n\n\t\t\t}\n\n\t\t\tif ( 'point3f[] points' in data ) {\n\n\t\t\t\tconst positions = JSON.parse( data[ 'point3f[] points' ].replace( /[()]*/g, '' ) );\n\t\t\t\tconst attribute = new BufferAttribute( new Float32Array( positions ), 3 );\n\t\t\t\tgeometry.setAttribute( 'position', attribute );\n\n\t\t\t}\n\n\t\t\tif ( 'normal3f[] normals' in data ) {\n\n\t\t\t\tconst normals = JSON.parse( data[ 'normal3f[] normals' ].replace( /[()]*/g, '' ) );\n\t\t\t\tconst attribute = new BufferAttribute( new Float32Array( normals ), 3 );\n\t\t\t\tgeometry.setAttribute( 'normal', attribute );\n\n\t\t\t} else {\n\n\t\t\t\tgeometry.computeVertexNormals();\n\n\t\t\t}\n\n\t\t\tif ( 'float2[] primvars:st' in data ) {\n\n\t\t\t\tdata[ 'texCoord2f[] primvars:st' ] = data[ 'float2[] primvars:st' ];\n\n\t\t\t}\n\n\t\t\tif ( 'texCoord2f[] primvars:st' in data ) {\n\n\t\t\t\tconst uvs = JSON.parse( data[ 'texCoord2f[] primvars:st' ].replace( /[()]*/g, '' ) );\n\t\t\t\tconst attribute = new BufferAttribute( new Float32Array( uvs ), 2 );\n\n\t\t\t\tif ( 'int[] primvars:st:indices' in data ) {\n\n\t\t\t\t\tgeometry = geometry.toNonIndexed();\n\n\t\t\t\t\tconst indices = JSON.parse( data[ 'int[] primvars:st:indices' ] );\n\t\t\t\t\tgeometry.setAttribute( 'uv', toFlatBufferAttribute( attribute, indices ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgeometry.setAttribute( 'uv', attribute );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction toFlatBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize );\n\n\t\t}\n\n\t\tfunction findMeshMaterial( data ) {\n\n\t\t\tif ( ! data ) return undefined;\n\n\t\t\tif ( 'rel material:binding' in data ) {\n\n\t\t\t\tconst reference = data[ 'rel material:binding' ];\n\t\t\t\tconst id = reference.replace( /^<\\//, '' ).replace( />$/, '' );\n\t\t\t\tconst parts = id.split( '/' );\n\n\t\t\t\treturn findMaterial( root, ` \"${ parts[ 1 ] }\"` );\n\n\t\t\t}\n\n\t\t\treturn findMaterial( data );\n\n\t\t}\n\n\t\tfunction findMaterial( data, id = '' ) {\n\n\t\t\tfor ( const name in data ) {\n\n\t\t\t\tconst object = data[ name ];\n\n\t\t\t\tif ( name.startsWith( 'def Material' + id ) ) {\n\n\t\t\t\t\treturn object;\n\n\t\t\t\t}\n\n\t\t\t\tif ( typeof object === 'object' ) {\n\n\t\t\t\t\tconst material = findMaterial( object, id );\n\n\t\t\t\t\tif ( material ) return material;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setTextureParams( map, data_value ) {\n\n\t\t\t// rotation, scale and translation\n\n\t\t\tif ( data_value[ 'float inputs:rotation' ] ) {\n\n\t\t\t\tmap.rotation = parseFloat( data_value[ 'float inputs:rotation' ] );\n\n\t\t\t}\n\n\t\t\tif ( data_value[ 'float2 inputs:scale' ] ) {\n\n\t\t\t\tmap.repeat = new Vector2().fromArray( JSON.parse( '[' + data_value[ 'float2 inputs:scale' ].replace( /[()]*/g, '' ) + ']' ) );\n\n\t\t\t}\n\n\t\t\tif ( data_value[ 'float2 inputs:translation' ] ) {\n\n\t\t\t\tmap.offset = new Vector2().fromArray( JSON.parse( '[' + data_value[ 'float2 inputs:translation' ].replace( /[()]*/g, '' ) + ']' ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildMaterial( data ) {\n\n\t\t\tconst material = new MeshPhysicalMaterial();\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\tif ( 'def Shader \"PreviewSurface\"' in data ) {\n\n\t\t\t\t\tconst surface = data[ 'def Shader \"PreviewSurface\"' ];\n\n\t\t\t\t\tif ( 'color3f inputs:diffuseColor.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'color3f inputs:diffuseColor.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.map = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.map.colorSpace = SRGBColorSpace;\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_diffuse\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.map, data[ 'def Shader \"Transform2d_diffuse\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( 'color3f inputs:diffuseColor' in surface ) {\n\n\t\t\t\t\t\tconst color = surface[ 'color3f inputs:diffuseColor' ].replace( /[()]*/g, '' );\n\t\t\t\t\t\tmaterial.color.fromArray( JSON.parse( '[' + color + ']' ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'color3f inputs:emissiveColor.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'color3f inputs:emissiveColor.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.emissiveMap = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.emissiveMap.colorSpace = SRGBColorSpace;\n\t\t\t\t\t\tmaterial.emissive.set( 0xffffff );\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_emissive\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.emissiveMap, data[ 'def Shader \"Transform2d_emissive\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( 'color3f inputs:emissiveColor' in surface ) {\n\n\t\t\t\t\t\tconst color = surface[ 'color3f inputs:emissiveColor' ].replace( /[()]*/g, '' );\n\t\t\t\t\t\tmaterial.emissive.fromArray( JSON.parse( '[' + color + ']' ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'normal3f inputs:normal.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'normal3f inputs:normal.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.normalMap = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.normalMap.colorSpace = NoColorSpace;\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_normal\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.normalMap, data[ 'def Shader \"Transform2d_normal\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'float inputs:roughness.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'float inputs:roughness.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.roughness = 1.0;\n\t\t\t\t\t\tmaterial.roughnessMap = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.roughnessMap.colorSpace = NoColorSpace;\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_roughness\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.roughnessMap, data[ 'def Shader \"Transform2d_roughness\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( 'float inputs:roughness' in surface ) {\n\n\t\t\t\t\t\tmaterial.roughness = parseFloat( surface[ 'float inputs:roughness' ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'float inputs:metallic.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'float inputs:metallic.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.metalness = 1.0;\n\t\t\t\t\t\tmaterial.metalnessMap = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.metalnessMap.colorSpace = NoColorSpace;\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_metallic\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.metalnessMap, data[ 'def Shader \"Transform2d_metallic\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( 'float inputs:metallic' in surface ) {\n\n\t\t\t\t\t\tmaterial.metalness = parseFloat( surface[ 'float inputs:metallic' ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'float inputs:clearcoat.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'float inputs:clearcoat.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.clearcoat = 1.0;\n\t\t\t\t\t\tmaterial.clearcoatMap = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.clearcoatMap.colorSpace = NoColorSpace;\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_clearcoat\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.clearcoatMap, data[ 'def Shader \"Transform2d_clearcoat\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( 'float inputs:clearcoat' in surface ) {\n\n\t\t\t\t\t\tmaterial.clearcoat = parseFloat( surface[ 'float inputs:clearcoat' ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'float inputs:clearcoatRoughness.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'float inputs:clearcoatRoughness.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.clearcoatRoughness = 1.0;\n\t\t\t\t\t\tmaterial.clearcoatRoughnessMap = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.clearcoatRoughnessMap.colorSpace = NoColorSpace;\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_clearcoatRoughness\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.clearcoatRoughnessMap, data[ 'def Shader \"Transform2d_clearcoatRoughness\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( 'float inputs:clearcoatRoughness' in surface ) {\n\n\t\t\t\t\t\tmaterial.clearcoatRoughness = parseFloat( surface[ 'float inputs:clearcoatRoughness' ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'float inputs:ior' in surface ) {\n\n\t\t\t\t\t\tmaterial.ior = parseFloat( surface[ 'float inputs:ior' ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( 'float inputs:occlusion.connect' in surface ) {\n\n\t\t\t\t\t\tconst path = surface[ 'float inputs:occlusion.connect' ];\n\t\t\t\t\t\tconst sampler = findTexture( root, /(\\w+).output/.exec( path )[ 1 ] );\n\n\t\t\t\t\t\tmaterial.aoMap = buildTexture( sampler );\n\t\t\t\t\t\tmaterial.aoMap.colorSpace = NoColorSpace;\n\n\t\t\t\t\t\tif ( 'def Shader \"Transform2d_occlusion\"' in data ) {\n\n\t\t\t\t\t\t\tsetTextureParams( material.aoMap, data[ 'def Shader \"Transform2d_occlusion\"' ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( 'def Shader \"diffuseColor_texture\"' in data ) {\n\n\t\t\t\t\tconst sampler = data[ 'def Shader \"diffuseColor_texture\"' ];\n\n\t\t\t\t\tmaterial.map = buildTexture( sampler );\n\t\t\t\t\tmaterial.map.colorSpace = SRGBColorSpace;\n\n\t\t\t\t}\n\n\t\t\t\tif ( 'def Shader \"normal_texture\"' in data ) {\n\n\t\t\t\t\tconst sampler = data[ 'def Shader \"normal_texture\"' ];\n\n\t\t\t\t\tmaterial.normalMap = buildTexture( sampler );\n\t\t\t\t\tmaterial.normalMap.colorSpace = NoColorSpace;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tfunction findTexture( data, id ) {\n\n\t\t\tfor ( const name in data ) {\n\n\t\t\t\tconst object = data[ name ];\n\n\t\t\t\tif ( name.startsWith( `def Shader \"${ id }\"` ) ) {\n\n\t\t\t\t\treturn object;\n\n\t\t\t\t}\n\n\t\t\t\tif ( typeof object === 'object' ) {\n\n\t\t\t\t\tconst texture = findTexture( object, id );\n\n\t\t\t\t\tif ( texture ) return texture;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildTexture( data ) {\n\n\t\t\tif ( 'asset inputs:file' in data ) {\n\n\t\t\t\tconst path = data[ 'asset inputs:file' ].replace( /@*/g, '' );\n\n\t\t\t\tconst loader = new TextureLoader();\n\n\t\t\t\tconst texture = loader.load( assets[ path ] );\n\n\t\t\t\tconst map = {\n\t\t\t\t\t'\"clamp\"': ClampToEdgeWrapping,\n\t\t\t\t\t'\"mirror\"': MirroredRepeatWrapping,\n\t\t\t\t\t'\"repeat\"': RepeatWrapping\n\t\t\t\t};\n\n\t\t\t\tif ( 'token inputs:wrapS' in data ) {\n\n\t\t\t\t\ttexture.wrapS = map[ data[ 'token inputs:wrapS' ] ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( 'token inputs:wrapT' in data ) {\n\n\t\t\t\t\ttexture.wrapT = map[ data[ 'token inputs:wrapT' ] ];\n\n\t\t\t\t}\n\n\t\t\t\treturn texture;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfunction buildObject( data ) {\n\n\t\t\tconst geometry = buildGeometry( findMeshGeometry( data ) );\n\t\t\tconst material = buildMaterial( findMeshMaterial( data ) );\n\n\t\t\tconst mesh = geometry ? new Mesh( geometry, material ) : new Object3D();\n\n\t\t\tif ( 'matrix4d xformOp:transform' in data ) {\n\n\t\t\t\tconst array = JSON.parse( '[' + data[ 'matrix4d xformOp:transform' ].replace( /[()]*/g, '' ) + ']' );\n\n\t\t\t\tmesh.matrix.fromArray( array );\n\t\t\t\tmesh.matrix.decompose( mesh.position, mesh.quaternion, mesh.scale );\n\n\t\t\t}\n\n\t\t\treturn mesh;\n\n\t\t}\n\n\t\tfunction buildHierarchy( data, group ) {\n\n\t\t\tfor ( const name in data ) {\n\n\t\t\t\tif ( name.startsWith( 'def Scope' ) ) {\n\n\t\t\t\t\tbuildHierarchy( data[ name ], group );\n\n\t\t\t\t} else if ( name.startsWith( 'def Xform' ) ) {\n\n\t\t\t\t\tconst mesh = buildObject( data[ name ] );\n\n\t\t\t\t\tif ( /def Xform \"(\\w+)\"/.test( name ) ) {\n\n\t\t\t\t\t\tmesh.name = /def Xform \"(\\w+)\"/.exec( name )[ 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgroup.add( mesh );\n\n\t\t\t\t\tbuildHierarchy( data[ name ], mesh );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst group = new Group();\n\n\t\tbuildHierarchy( root, group );\n\n\t\treturn group;\n\n\t}\n\n}\n\nexport { USDZLoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}